---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by shuieryin.
--- DateTime: 12/01/2018 10:44 PM
---

require 'computeNumericalGradient'

function checkCostFunction(lambda)
    --CHECKCOSTFUNCTION Creates a collaborative filering problem
    --to check your cost function and gradients
    --   CHECKCOSTFUNCTION(lambda) Creates a collaborative filering problem
    --   to check your cost function and gradients, it will output the
    --   analytical gradients produced by your code and the numerical gradients
    --   (computed using computeNumericalGradient). These two gradient
    --   computations should result in very similar values.

    -- Set lambda
    lambda = lambda or 0

    -- Create small problem
    local X_t = torch.rand(4, 3)
    local Theta_t = torch.rand(5, 3)

    -- Zap out most entries
    local Y = X_t * Theta_t:t()
    Y[torch.rand(Y:size()):gt(0.5)] = 0
    local R = torch.zeros(Y:size())
    R[Y:ne(0)] = 1

    -- Run Gradient Checking
    local X = torch.randn(X_t:size())
    local Theta = torch.randn(Theta_t:size())
    local num_users = Y:size(2)
    local num_movies = Y:size(1)
    local num_features = Theta_t:size(2)

    local params = torch.reshape(X, X:numel()):cat(torch.reshape(Theta, Theta:numel()))
    local numgrad = computeNumericalGradient(function(t)
        return cofiCostFunc(t, Y, R, num_users, num_movies, num_features, lambda)
    end, params)

    local cost, grad = cofiCostFunc(params, Y, R, num_users, num_movies, num_features, lambda)

    print(numgrad:cat(grad, 2))
    print('The above two columns you get should be very similar.\n(Left-Your Numerical Gradient, Right-Analytical Gradient)')

    local diff = torch.norm(numgrad - grad) / torch.norm(numgrad + grad)
    print('If your cost function implementation is correct, then \n' ..
            'the relative difference will be small (less than 1e-9). \n' ..
            '\nRelative Difference:', diff)

end